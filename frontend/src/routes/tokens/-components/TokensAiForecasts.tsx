import { useState } from "react";
import CloseIcon from "@mui/icons-material/Close";
import {
  Box,
  Button,
  Chip,
  CircularProgress,
  Dialog,
  DialogContent,
  DialogTitle,
  IconButton,
  Stack,
  Typography,
} from "@mui/material";

import { useToast } from "@/hooks/useToast";
import { useTokensAiForecasts } from "@/routes/tokens/-api/useTokensAiForecasts";
import { useFiltersForMode } from "@/store/useFiltersStore";
import { getErrorMessage } from "@/utils/errorUtils";

import {
  buttonForecastStyles,
  closeButtonSx,
  dialogPaperSx,
  forecastModalItemStyles,
  forecastModalStyles,
  SENTIMENT_COLORS,
} from "../-utils/tokensStyles";

interface TokenForecast {
  token_name: string;
  sentiment: string;
  forecast_text: string;
}

function isTokenForecast(data: unknown): data is TokenForecast {
  if (typeof data !== "object" || data === null) return false;
  const d = data as Record<string, unknown>;
  return (
    typeof d.token_name === "string" &&
    typeof d.sentiment === "string" &&
    typeof d.forecast_text === "string"
  );
}

export default function TokensAiForecasts() {
  const { selectedToken } = useFiltersForMode();
  const [open, setOpen] = useState(false);
  const { showError } = useToast();

  const { data: forecastData, isLoading, refetch } = useTokensAiForecasts();
  const forecast = isTokenForecast(forecastData) ? forecastData : null;

  const handleOpen = async () => {
    if (!selectedToken) return;

    if (forecast) {
      setOpen(true);
      return;
    }

    try {
      const { data } = await refetch();
      if (data) {
        setOpen(true);
      } else {
        showError("Forecast for this token is not available yet.");
      }
    } catch (err) {
      showError(
        getErrorMessage(
          err,
          "Failed to load forecast. Please try again later.",
        ),
      );
    }
  };

  return (
    <>
      <Button
        onClick={() => void handleOpen()}
        disabled={!selectedToken || isLoading}
        variant="contained"
        sx={buttonForecastStyles}
      >
        {isLoading ? (
          <Box display="flex" alignItems="center" gap={1}>
            <CircularProgress size={16} sx={{ color: "#fff" }} />
            Loading...
          </Box>
        ) : (
          "ðŸ“ˆ AI Forecast"
        )}
      </Button>

      <Dialog
        open={open}
        onClose={() => setOpen(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{ sx: dialogPaperSx }}
        slotProps={{
          backdrop: {
            sx: {
              backgroundColor: "rgba(0, 0, 0, 0.8)",
              backdropFilter: "blur(4px)",
            },
          },
        }}
      >
        <DialogTitle sx={forecastModalStyles}>
          <Typography variant="h6" fontWeight={600}>
            {forecast !== null
              ? `Forecast for ${selectedToken?.value}`
              : "AI Forecast"}
          </Typography>
          <IconButton
            onClick={() => setOpen(false)}
            size="small"
            sx={closeButtonSx}
          >
            <CloseIcon />
          </IconButton>
        </DialogTitle>

        <DialogContent sx={forecastModalItemStyles}>
          {forecast !== null && <ForecastContent forecast={forecast} />}
        </DialogContent>
      </Dialog>
    </>
  );
}

function ForecastContent({ forecast }: { forecast: TokenForecast }) {
  const sentiment = forecast.sentiment || "neutral";
  const sentimentColor =
    SENTIMENT_COLORS[sentiment] ?? SENTIMENT_COLORS.neutral;

  return (
    <Stack spacing={2} alignItems="center">
      <Chip
        label={sentiment}
        sx={{ ...sentimentColor, fontWeight: 500, textTransform: "capitalize" }}
      />

      <Typography
        variant="body1"
        sx={{
          color: "#e5e7eb",
          lineHeight: 1.8,
          whiteSpace: "pre-wrap",
          textAlign: "center",
        }}
      >
        {forecast.forecast_text}
      </Typography>

      <Typography
        variant="caption"
        sx={{ color: "#6b7280", fontStyle: "italic" }}
      >
        Generated by AI
      </Typography>
    </Stack>
  );
}
